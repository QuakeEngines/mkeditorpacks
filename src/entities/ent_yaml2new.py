#!/usr/bin/env python3

import yaml
import re
import sys
import os.path
import argparse


bad_token_re = re.compile(r'[}{)(\':\s]', re.M)

def escape_token(t):
    if bad_token_re.search(t):
        if t.find('"') >= 0:
            raise Exception('Bad token: {}'.format(t))
        return '"{}"'.format(t)
    return t

def color_to_float_triple(h):
    hexes = [h[:2], h[2:4], h[4:]]
    return [round(int(x, 16) / 255.0, 3) for x in hexes]



def list_of_dicts_to_list_of_tuples(dd):
    res = []
    for d in dd:
        for k, v in d.items():
            res.append((k, v))
            break
    return res


# ==============================================================================
# entity output in native radiant format


# https://github.com/TTimo/GtkRadiant/issues/262
dont_place_dummy_flag = True

heading = '------ {} ------'

starting_text = \
'''// !!! THIS FILE IS AUTOGENERATED, DO NOT EDIT
// Unvanquished entity definitions file for GTKRadiant 1.5/NetRadiant
// Update 2012-08-22 by Ingar: created template entities.def for Unvanquished

// Based on Tremulous entity definition file for GTKRadiant
// by Tim Angus <tma@op.ath.cx> 2003-09-08
// Update 2007-01-24 by Warrior: removed some references to bots, added
// the team_alien_hive entity and fixed team_alien_acid_tube coordinates.
// Update 2009-02-14 by Ingar: merged gpp1 entities.def

// Based on entities.def from GTKRadiant 1.3.11 which in turn is based on...
// Based on draft by Suicide 20 1999-07-30 and inolen 1999-09-03
// Upgraded by Eutectic: eutectic@ritualistic.com
// (visible models added by raYGunn - paths provided by Suicide 20)
// (terrain information added to func_group entity by Paul Jaquays)
// Q3Map2 entitys/keys added by ydnar
'''

def fmt_float(f):
    x = '{:f}'.format(f)
    if 'e' in x:
        return x
    return x.rstrip('0').rstrip('.')


def print_entity_head(e):
    name = escape_token(e['name'])
    color = '({} {} {})'.format(*(fmt_float(f) for f in color_to_float_triple(e['color'])))
    flags = [escape_token(k) for k, _ in e['flags']]
    if 'size_min' in e and 'size_max' in e:
        sizes = ' ({} {} {}) ({} {} {})'.format(*(fmt_float(f) for f in e['size_min'] + e['size_max']))
    else:
        sizes = ''
        if not dont_place_dummy_flag:
            flags.insert(0, escape_token('?'))
    flags = ' '.join(flags)
    if flags:
        flags = ' ' + flags
    print('/*QUAKED {} {}{}{}'.format(name, color, sizes, flags))


def print_flag_desc(e):
    flags = []
    for k, v in e['flags']:
        if k == '-' or not v:
            continue
        flags.append('{}: {}'.format(k, v))
    if flags:
        print(heading.format('FLAGS'))
        for v in flags:
            print(v)


def print_prop_desc(e):
    props = []
    for k, v in sorted(e['props'].items()):
        props.append('{}: {}'.format(k, v))
    if props:
        print(heading.format('PROPERTIES'))
        for v in props:
            print(v)


def print_common_desc(e):
    if e['desc']:
        print(heading.format('DESCRIPTION'))
        print(e['desc'])


def print_specials(e):
    if e['specials']:
        for k, v in e['specials'].items():
            print('{}="{}"'.format(k, v))


def print_entity(e, dt):
    print_entity_head(e)
    print_flag_desc(e)
    print_prop_desc(e)
    print_common_desc(e)
    print_specials(e)
    print('*/')
    print()


# ==============================================================================
# validators


def _validate_int(v):
    return type(v) == int

def _validate_string(v):
    return type(v) == str

def _validate_float(v):
    return type(v) in (int, float)

def _validate_vec2_float(v):
    return len(v) == 2 and all(_validate_float(x) for x in v)

def _validate_vec3_float(v):
    return len(v) == 3 and all(_validate_float(x) for x in v)

def _validate_vec4_float(v):
    return len(v) == 3 and all(_validate_float(x) for x in v)


def validate_entity(e, dt):
    r = []
    props = set(e['props'].keys())
    propreplace = set(e.get('propreplace', {}).keys())
    proptypes = set(e.get('proptypes', {}).keys())
    propdefaults = set(e.get('propdefaults', {}).keys())
    boolvalues = set(e.get('boolvalues', {}).keys())

    x = propreplace - props
    if x:
        r.append('Non-existent properties ({}) in propreplace: {}'.format(len(x), x))
    x = proptypes - props
    if x:
        r.append('Non-existent properties ({}) in proptypes: {}'.format(len(x), x))
    x = propdefaults - props
    if x:
        r.append('Non-existent properties ({}) in propdefaults: {}'.format(len(x), x))
    x = boolvalues - props
    if x:
        r.append('Non-existent properties ({}) in boolvalues: {}'.format(len(x), x))

    mergedtypes = proptypes | set(dt.keys())
    # if we have default, we must have known type
    x = propdefaults - mergedtypes
    if x:
        r.append('Properties ({}) in defaults are not exist in types: {}'.format(len(x), x))

    # validate types of default values
    unknown_types = set()
    etypes = e.get('proptypes', {})
    for field in propdefaults & mergedtypes:
        ftype = etypes[field] if field in etypes else dt[field]
        if ' ' in ftype:
            ftype, _ = ftype.split(' ', 1)

        # proptypes must not duplicate deftypes
        if field in etypes and field in dt and ftype == dt[field]:
            r.append('Property type {}:{} duplicates entry from deftypes'.format(field, ftype))

        func_name = '_validate_{}'.format(ftype)
        if func_name not in globals():
            unknown_types.add(ftype)
        else:
            v = e['propdefaults'][field]
            if type(v) == bool and field in boolvalues:
                if type(e['boolvalues']) != list or len(e['boolvalues']) != 2:
                    r.append('Invalid bool list of prop {}'.format(field))
                else:
                    for bv in e['boolvalues']:
                        if not globals()[func_name](bv):
                            r.append('Invalid bool value {} of prop {}, must be of type {}'.format(bv, field, ftype))
            elif not globals()[func_name](v):
                r.append('Invalid default value of {}: {}, must be of type {}'.format(field, v, ftype))

    if unknown_types:
        r.append('Types ({}) are unknown: {}'.format(len(unknown_types), unknown_types))

    return r


# ==============================================================================
# coverage


def entity_type_coverage(e, dt):
    props = set(e['props'].keys())
    proptypes = set(e.get('proptypes', {}).keys())
    propdefaults = set(e.get('propdefaults', {}).keys())

    t = proptypes | (props & set(dt.keys()))

    if len(t) < len(props):
        print('{}%: {}'.format(len(t) * 100 // len(props), e['name']))


# ==============================================================================
# main


def create_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument('--yamlname', default='entities.yaml')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--validate', action='store_true', help='Make validation of yaml contents')
    group.add_argument('--generate', action='store_true', help='Print final entities file')
    group.add_argument('--coverage', action='store_true', help='Analyse fullfillness of data')
    return parser

def load_main_file(name):
    with open(name, 'r') as f:
        text = f.read()
        elist = yaml.load(text)
        # autofix data
        for e in elist:
            e['flags'] = list_of_dicts_to_list_of_tuples(e['flags'])
    return elist

def get_deftypes_name(mainname):
    d = os.path.dirname(mainname)
    fname = os.path.basename(mainname).split('.')
    if fname[-1] in ('yaml', 'yml'):
        fname.insert(-1, 'deftypes')
    else:
        fname.append('deftypes')
    return os.path.join(d, '.'.join(fname))

def load_deftypes_file(name):
    if not os.path.isfile(name):
        return {}
    with open(name, 'r') as f:
        text = f.read()
        deftypes = yaml.load(text)
    return deftypes


args = create_parser().parse_args()
elist = load_main_file(args.yamlname)
deftypes = load_deftypes_file(get_deftypes_name(args.yamlname))

if args.validate:
    warns = []
    for e in elist:
        w = validate_entity(e, deftypes)
        w = ['{}: {}'.format(e['name'], line) for line in w]
        warns.extend(w)

    for w in warns:
        print(w)
    if not warns:
        print('No warinings! File is OK.')
    else:
        exit(1)
elif args.coverage:
    for e in elist:
        entity_type_coverage(e, deftypes)
elif args.generate:
    print(starting_text)
    for e in elist:
        print_entity(e, deftypes)
else:
    print('Choose action!')
